p_values <- matrix(NA, nrow = g, ncol = n_weights)
for (j in 1:k) {
for (i in 1:n_weights) {
w <- as.matrix(all_weights[i, ])
statistic <- sum(w * (-2 * log(pmat[j, ])))
perm_statistic <- numeric(n)
for (perm_i in 1:n) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat <- p_matrix(perm_datalist)
perm_w <- w[sample(nrow(w)), ]
perm_sum <- 0
for (perm_j in 1:nrow(perm_pmat)) {
perm_sum <- perm_sum + sum(perm_w[perm_j, ] * (-2 * log(perm_pmat[perm_j, ])))
}
perm_statistic[perm_i] <- perm_sum
}
p_values[j, i] <- mean(statistic <= perm_statistic)
}
}
return(p_values)
}
weighted_fisher_permutation(dl,n=10)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
# Calculate p-values using observed data
pmat <- p_matrix(datalist)
p_values_observed <- apply(pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
# Initialize matrix to store permuted p-values
p_values_permuted <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
# Generate all possible weight combinations
g <- nrow(pmat)
all_weights <- expand.grid(replicate(g, c(0, 1), simplify = FALSE))
# Iterate over all weights
for (i in 1:nrow(all_weights)) {
w <- as.matrix(all_weights[i, ])
perm_pmat <- matrix(NA, nrow = nrow(pmat), ncol = ncol(pmat))
# Iterate over all permutations
for (j in 1:n_permutations) {
# Shuffle each study's data separately
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat[, ] <- p_matrix(perm_datalist)
# Calculate weighted statistic for permuted data
perm_statistic <- apply(perm_pmat, 1, function(pvec) sum(w * (-2 * log(pvec))))
# Calculate p-value for permuted data
p_values_permuted[, j] <- apply(perm_pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
}
# Calculate weighted p-value for current weight combination
permuted_weights <- apply(p_values_permuted, 1, function(pvec) sum(pvec <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
# Update p-value for each study
for (j in 1:g) {
p_values_observed[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p_values_observed)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
s_ob <- apply(pmat,1,FUN = function(p_values) -2 * sum(log(p_values)))
df <- 2 * ncol(pmat)
p_ob <- 1 - pchisq(statistic, df)
p_perm<- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
g <- nrow(pmat)
all_weights <- expand.grid(replicate(g, c(0, 1), simplify = FALSE))
for (i in 1:nrow(all_weights)) {
w <- as.matrix(all_weights[i, ])
perm_pmat <- matrix(NA, nrow = nrow(pmat), ncol = ncol(pmat))
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat[, ] <- p_matrix(perm_datalist)
perm_statistic <- apply(perm_pmat, 1, function(pvec) sum(w * (-2 * log(pvec))))
p_values_permuted[, j] <- apply(perm_pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
}
permuted_weights <- apply(p_values_permuted, 1, function(pvec) sum(pvec <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:g) {
p_values_observed[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p_values_observed)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
df <- 2 * ncol(pmat)
p_perm <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
g <- nrow(pmat)
all_weights <- expand.grid(replicate(g, c(0, 1), simplify = FALSE))
for (i in 1:nrow(all_weights)) {
w <- as.matrix(all_weights[i, ])
perm_pmat <- matrix(NA, nrow = nrow(pmat), ncol = ncol(pmat))
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat[, ] <- p_matrix(perm_datalist)
p_values_permuted[, j] <- apply(perm_pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
}
permuted_weights <- apply(p_values_permuted, 1, function(pvec) sum(pvec <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:g) {
p_values_observed[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p_values_observed)
}
weighted_fisher_permutation(dl)
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
df <- 2 * ncol(pmat)
p_perm <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
g <- nrow(pmat)
all_weights <- expand.grid(replicate(ncol(pmat), c(0, 1), simplify = FALSE))
for (i in 1:nrow(all_weights)) {
w <- as.matrix(all_weights[i, ])
perm_pmat <- matrix(NA, nrow = nrow(pmat), ncol = ncol(pmat))
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat[, ] <- p_matrix(perm_datalist)
p_values_permuted[, j] <- apply(perm_pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
}
permuted_weights <- apply(p_values_permuted, 1, function(pvec) sum(pvec <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:g) {
p_values_observed[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p_values_observed)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
g <- nrow(pmat)
all_weights <- expand.grid(replicate(g, c(0, 1), simplify = FALSE))
p_values_observed <- rep(1, g)
for (i in 1:nrow(all_weights)) {
w <- as.matrix(all_weights[i, ])
p_values_permuted <- matrix(NA, nrow = g, ncol = n_permutations)
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat <- p_matrix(perm_datalist)
perm_statistic <- apply(perm_pmat, 1, function(pvec) sum(w * (-2 * log(pvec))))
p_values_permuted[, j] <- apply(perm_pmat, 1, function(pvec) -2 * sum(w * log(pvec)))
}
permuted_weights <- apply(p_values_permuted, 1, function(pvec) sum(pvec <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
p_values_observed <- pmin(p_values_observed, p_value)
}
p_values_observed
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
df <- 2 * ncol(pmat)
p_perm <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
g <- nrow(pmat)
all_weights <- expand.grid(replicate(g, c(0, 1), simplify = FALSE))
p_values_permuted <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations) # initialize here
p_values_observed <- apply(pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
for (i in 1:nrow(all_weights)) {
w <- as.matrix(all_weights[i, ])
perm_pmat <- matrix(NA, nrow = nrow(pmat), ncol = ncol(pmat))
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat[, ] <- p_matrix(perm_datalist)
p_values_permuted[, j] <- apply(perm_pmat, 1, function(pvec) sum(w * (-2 * log(pvec))))
}
permuted_weights <- apply(p_values_permuted, 1, function(pvec) sum(pvec <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:g) {
p_values_observed[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p_values_observed)
}
weighted_fisher_permutation(dl)
all_weights <- expand.grid(replicate(ncol(pmat), c(0, 1), simplify = FALSE))
all_weights
as.matrix(all_weights[i, ])
unname(expand.grid(replicate(ncol(pmat), c(0, 1), simplify = FALSE)))
w <- all_weights[1, ]
w
unname(expand.grid(replicate(ncol(pmat), c(0, 1), simplify = FALSE)))[-1]
unname(expand.grid(replicate(ncol(pmat), c(0, 1), simplify = FALSE)))[-1,]
all_weights <- unname(expand.grid(replicate(ncol(pmat), c(0, 1), simplify = FALSE)))[-1,]
all_weights[1,]
all_weights <- unname(expand.grid(replicate(ncol(pmat), c(0, 1))))[-1,]
all_weights
all_weights <- unname(expand.grid(replicate(ncol(pmat), c(0, 1))))[-1,]
all_weights
all_weights <- unname(expand.grid(replicate(ncol(pmat), c(0, 1))))
all_weights
all_weights <- expand.grid(rep(list(0:1),ncol(pmat))
w<-c()
all_weights <- expand.grid(rep(list(0:1),ncol(pmat)))
all_weights
expand.grid(rep(list(0:1),ncol(pmat)))[-1,]
expand.grid(rep(list(0:1),ncol(pmat)))[-1,][1,]
2*expand.grid(rep(list(0:1),ncol(pmat)))[-1,][1,]
all_weights <- expand.grid(rep(list(0:1),ncol(pmat)))[-1,]
all_weights[i, ]
all_weights[1, ]
w <- all_weights[i, ]
w
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat<-p_matrix(datalist)
statistic_obs <- apply(pmat,1,FUN = function(p_values) -2 * sum(log(p_values)))
df <- 2 * ncol(pmat)
p_value_obs <- 1 - pchisq(statistic_obs, df)
all_weights <- expand.grid(rep(list(0:1),ncol(pmat)))[-1,]
w<-c()
for (i in 1:nrow(all_weights)) {
w <- all_weights[i, ]
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat<- p_matrix(perm_datalist)
statistic_perm <- apply(perm_pmat, 1, FUN = function(p_values) -2 * sum(log(p_values)))
df_perm<- 2 * ncol(perm_pmat)
p_value_permuted <- 1 - pchisq(statistic_perm, df_perm)
}
permuted_weights <- apply(p_values_permuted, 1, function(p_values) sum(p_values <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:g) {
p_values_observed[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p_values_observed)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat<-p_matrix(datalist)
statistic_obs <- apply(pmat,1,FUN = function(p_values) -2 * sum(log(p_values)))
df <- 2 * ncol(pmat)
p_value_obs <- 1 - pchisq(statistic_obs, df)
all_weights <- expand.grid(rep(list(0:1),ncol(pmat)))[-1,]
w<-c()
p<-c()
for (i in 1:nrow(all_weights)) {
w <- all_weights[i, ]
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat<- p_matrix(perm_datalist)
statistic_perm <- apply(perm_pmat, 1, FUN = function(p_values) -2 * sum(log(p_values)))
df_perm<- 2 * ncol(perm_pmat)
p_value_permuted <- 1 - pchisq(statistic_perm, df_perm)
}
permuted_weights <- apply(p_value_permuted, 1, function(p_values) sum(p_values <= p_value_obs))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:g) {
p[j] <- pmin(p_values_obs[j], p_value)
}
}
return(p)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
statistic_obs <- apply(pmat, 1, FUN = function(p_values) -2 * sum(log(p_values)))
df <- 2 * ncol(pmat)
p_values_observed <- apply(pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
all_weights <- expand.grid(rep(list(0:1), ncol(pmat)))[-1, ]
p <- rep(NA, ncol(pmat))
for (i in 1:nrow(all_weights)) {
w <- all_weights[i, ]
p_values_permuted <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat <- p_matrix(perm_datalist)
statistic_perm <- apply(perm_pmat, 1, FUN = function(p_values) -2 * sum(log(p_values)))
df_perm <- 2 * ncol(perm_pmat)
p_value_permuted <- 1 - pchisq(statistic_perm, df_perm)
p_values_permuted[, j] <- apply(perm_pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
}
permuted_weights <- apply(p_values_permuted, 1, function(p_values) sum(p_values <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:ncol(pmat)) {
p[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
statistic_obs <- apply(pmat, 1, FUN = function(p_values) -2 * sum(log(p_values)))
df <- 2 * ncol(pmat)
p_values_observed <- apply(pmat, 1, function(pvec) fisher_combine(-2 * log(pvec)))
all_weights <- expand.grid(rep(list(0:1), ncol(pmat)))[-1, ]
p <- rep(NA, ncol(pmat))
for (i in 1:nrow(all_weights)) {
w <- all_weights[i, ]
p_values_permuted <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat <- p_matrix(perm_datalist)
p_values_permuted <- fisher(perm_datalist)
}
permuted_weights <- apply(p_values_permuted, 1, function(p_values) sum(p_values <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:ncol(pmat)) {
p[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
p_values_observed <-fisher(datalist)
all_weights <- expand.grid(rep(list(0:1), ncol(pmat)))[-1, ]
p <- rep(NA, ncol(pmat))
for (i in 1:nrow(all_weights)) {
w <- all_weights[i, ]
p_values_permuted <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat <- p_matrix(perm_datalist)
p_values_permuted <- fisher(perm_datalist)
}
permuted_weights <- apply(p_values_permuted, 1, function(p_values) sum(p_values <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:ncol(pmat)) {
p[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
p_values_observed <- fisher(datalist)$p_value
all_weights <- expand.grid(rep(list(0:1), ncol(pmat)))[-1, ]
p <- rep(NA, ncol(pmat))
for (i in 1:nrow(all_weights)) {
w <- all_weights[i, ]
p_values_permuted <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat <- p_matrix(perm_datalist)
p_values_permuted[, j] <- fisher(perm_datalist)$p_value
}
permuted_weights <- apply(p_values_permuted, 1, function(p_values) sum(p_values <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:ncol(pmat)) {
p[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p)
}
weighted_fisher_permutation(dl)
#' @title weighted fisher permutation
#' @description The AW fisher's method assigns different weights to each individual study\deqn{T_{AW} = -\sum_{k=1}^{K} w_{k} log(P_{i}), w_{k}=0 or 1}
#' and it searches through all possible weight to find the best adaptive weight with the smallest derived p-value.
#' @param datalist Input datalist
#' @param n  Number of permutation
#' @param p.adj  p values adjustment, default p.adj = FALSE
#' @return p_value
#' @return statistic if stat=TRUE
#' @examples
#' @export
weighted_fisher_permutation <- function(datalist, n_permutations = 100) {
pmat <- p_matrix(datalist)
p_values_observed <- fisher(datalist)$p_value
all_weights <- expand.grid(rep(list(0:1), ncol(pmat)))[-1, ]
p <- rep(NA, ncol(pmat))
for (i in 1:nrow(all_weights)) {
w <- all_weights[i, ]
p_values_permuted <- matrix(NA, nrow = nrow(pmat), ncol = n_permutations)
for (j in 1:n_permutations) {
perm_datalist <- lapply(datalist, function(df) df[sample(nrow(df)), ])
perm_pmat <- p_matrix(perm_datalist)
p_values_permuted[, j] <- fisher(perm_datalist)$p_value
}
permuted_weights <- apply(p_values_permuted, 1, function(p_values) sum(p_values <= p_values_observed))
p_value <- sum(permuted_weights * w) / sum(w)
for (j in 1:nrow(pmat)) {
p[j] <- pmin(p_values_observed[j], p_value)
}
}
return(p)
}
weighted_fisher_permutation(dl)
source("~/bioMetaLin/R/p_matrix.R", echo=TRUE)
devtools::build()
devtools::document()
devtools::load_all()
devtools::build()
devtools::build()
devtools::document()
devtools::build()
devtools::build()
devtools::document()
devtools::build()
