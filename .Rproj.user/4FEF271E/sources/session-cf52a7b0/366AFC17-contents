---
title: "AMS 597 NOTE"
author: "Zhiwei Lin"
date: "2023-02-08"
output: html_document
---
# Note 1
```{r}
fruits <- c("apple", "banana", "cherry", "orange")
matching_indices <- grep("an", fruits)
print(matching_indices)
matching_positions <- gregexpr("an", fruits) 

length(matching_positions)
#grep() returns the indices of the elements in a vector that match a specified pattern, while gregexpr() returns the positions of the matches within each element of a vector as a list.

# Example string
my_string <- "hello world"
# Get the length of the string
string_len <- nchar(my_string)
# Get the middle part of the string
middle <- substr(my_string, start = ceiling(string_len / 2), stop = floor(string_len / 2) + 1)
# Convert the middle part to uppercase
middle_upper <- toupper(middle)
# Replace the original middle part with the uppercase version
new_string <- paste0(substr(my_string, start = 1, stop = ceiling(string_len / 2) - 1), middle_upper, substr(my_string, start = floor(string_len / 2) + 2, stop = string_len))
# Print the new string
print(new_string)

```
```{r}
mydna <- paste(sample(c("a","t","c","g"),1000,replace=T),collapse="")
num_cg <- length(gregexpr("cg", mydna)[[1]])
```


### string manipulation
```{r}
a <- 12345
b <- as.character(a)
nchar(a)
a <- "UPPERlower"
toupper(a)
tolower(a)
a <- "butter"
chartr("u","e", a) # character translation from u to e. case sensitive
a <- "BUTTER"
chartr("u","e", a)
old <- c("BT")
new <- c("GN")
chartr(old, new, a)
```

```{r}
a <- "12345678"
substr(a,2,2).   # substrings 
substring(a,2).  # this is better, no need end.
```

```{r}
a = "12345"
b = "6789"
paste(a, b).   # string concatenation
paste(a, b, sep = "")
paste(a, b, sep = "honda")
```

```{r}
a <- "1,2,3,4,5,6,7,8,9"
b <- strsplit(a, split =",").  #string splitting
b
class(b)
strsplit(a, split = "")
a <- c("1,2,3", "4,5,6", "7,8,9", "a,b,c", ",,asdf,,,")
strsplit(a,",")
```

### regular expression
```{r}
a <- c("asdf","asbf","dfdf", "12365)")
grep("d", a, perl=TRUE) # index 
grep("d", a, perl=TRUE, value=TRUE) # value
# grep is to find regular expression matches in x
grepl("df", a)
# grepl() returns a logical vector with the same length as the input vector.
regexpr("df", a, perl=TRUE) 
gregexpr("df", a, perl=TRUE) # this one is more useful  returns a vector of all the starting positions of matches found in the string
gsub("(df)", "8\\18", a, perl=TRUE)
gsub("df", "8\\18", a, perl=TRUE)
gsub("(df)", "8\\U\\18", a, perl=TRUE)
# replace matches in x with a string
```

### How do you check if a string is a palindrome?
```{r}
x <- "hello"
x == rev(x)

palindrome <- function(x){
  x<-strsplit(x,"")[[1]]
  y<-c()
  for(i in 1:length(x)) y[i] <- x[length(x)-i+1]
  if (all(y == x))  return (TRUE)
  else return(FALSE)
}
palindrome(x)
```
```{r}
x <- c(red="Huey", blue="Dewey", green="Louie")
names(x)
matrix(1:12,nrow=3,byrow=T)
x <- matrix(1:12,nrow=3,byrow=T)
rownames(x) <- LETTERS[1:3]
t(x)
```



### Fibonacci sequence 
```{r}
Fib <- function(N){
  if (N <= 0 | N != round(N)) {
    stop ("n must be greater than 0 and has to be an integer")
  }
  cat("Computing Fibonacci sequence for N=", N,"\n")
  if (N == 1) x = 1
  else if (N == 2) x = c(1,1)
  else {
    x<- vector()
    x[1:2]<-1
    for (i in 3:N){
      x[i] <- x[i-1]+x[i-2]
    }
  }
  return(x)
}
Fib(10)
```

#Note 2
```{r}
library(dplyr)
data(thuesen)
thue2 <- subset(thuesen, blood.glucose < 7)
thue2
thue1 <- thuesen[thuesen$blood.glucose < 7,]
thue1
thue3 <- filter(thuesen, blood.glucose<7)
```

```{r}
thue2_1 <- transform(thuesen, log.gluc = log(blood.glucose)). # create new column.
thue2_1[1:5, ]
df <- data.frame(x = c(1, 2, 3), y = c(4, 5, 6))
df <- transform(df, z = x + y)
df <- mutate(df, z = x + y)

arrange(df, x, y) # reorder 
df[order(df$x,df$y),]
```
### Exercise: How to select all columns except “name’’?
```{r}
mydat <- data.frame(month = rep(12:1, each = 30),
    day = rep(1:30, 12), name = rep(c("Bob",
        "Rob", "Deb", "Ann"), each = 90),
    mscore = runif(360))
mydate <- select(mydat, -name)
mydate_basic <-mydat[, !colnames(mydat) %in% ("name")]

## How about column which starts with “m’’?
mydate_subset <- mydat[, regexpr("^m", colnames(mydat)) == 1]
mydat_subset <- mydat[, grepl("^m.*", names(mydat))]
mydat_subset <- mydat %>% select(matches("^m.*"))

```

#Note 3
```{r}
sample(1:40,5)
sample(c("H","T"), 10, replace=T)
sample(c("succ", "fail"), 10, replace=T, prob=c(0.9, 0.1))
# sample is used to create an vector
# matrix is create a matrix
```
apply function is used to apply a function to the rows or column of a matrix or dataframe. 
```{r}
# Create a 3x3 matrix of random numbers
m <- matrix(rnorm(9), ncol = 3)
# Use apply() to calculate the sum of each column, 1 is row 2 is column 
colsums <- apply(m, 2, sum)
# Print the resulting vector of column sums
print(colsums)

# lapply() is used for list
my_list <- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))
result_list <- lapply(my_list, mean)
print(result_list)

# sapply() is used for list and matrix 
my_list <- list(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))
result_vector <- sapply(my_list, mean)
print(result_vector)
```

Quantiles: If we have n normally distributed observations with the same mean μ and standard deviation σ, then it is known that the average X̄ is normally distributed around μ with standard deviation σ/sqrt(n).
```{r}
set.seed(123)
mu1 <- 2.   # mean 
sd1 <- 3.   # standard deviation 
n <- 20     # number of sample
r <- 100.  # repeat 100 times
# x_bar ~ N(mu1, sd1^2/n)
x<- matrix(rnorm(n*r,mu1,sd1),nrow=r)

#xbar <- rep(NA,r)
#for(i in 1:r)xbar[i] <- mean(x[i,])
xbar <- apply(x,1,mean)

qqnorm(xbar)
mean(xbar)
sd(xbar)
sd1/sqrt(n)
```
Exercise: Write a function to sample from binomial distribution without using rbinom and other binom functions.
```{r}
binomial_sample <- function(r,n,p){
  i<- 0:n
  p1<- choose(n,i)*p^i*(1-p)^(n-i)
  x <- sample(i,size=r, prob=p1,replace = T)
  return(x)
}
binomial_sample(10,100,0.2)

p=0.2
r=10
i<- 0:n
p1<- choose(n,i)*p^i*(1-p)^(n-i)
x <- sample(i,size=r, prob=p1,replace = T) 

-----------------
my_exp <- function(n, lambda) {
  u <- runif(n)
  x <- -log(1 - u) / lambda
  return(x)
}
X = -ln(1 - U) / lambda
-----------
my_poisson <- function(n, lambda) {
  x <- numeric(n)
  for (i in 1:n) {
    t <- 0
    k <- 0
    while (t < 1) {
      k <- k + 1
      t <- t - log(runif(1)) / lambda
    }
    x[i] <- k - 1
  }
  return(x)
}

```
Exercise: Illustrate the CLT with simulations using random uniform U(0,1) variables
```{r}
n<- 50 
r<- 1000
x<-matrix(runif(n*r),ncol=n)
xbar <- apply(x,1,mean)
par(mfrow=c(1,2))
hist(xbar)
qqnorm(xbar)
qqline(xbar)
```
Exercise: First write a function which generates a matrix containing random uppercase letters of size n × p. Then, write a function which returns the most frequent character for each row of such matrix.
```{r}
set.seed(123)
myABCmat <- function(n,p){
  x<-matrix(sample(LETTERS,n*p,replace=TRUE),nrow=n)
  return(x)
}

my.sub.f <- function(x){
  tab1 <- table(x)
  return(names(tab1)[which(tab1==max(tab1))])
}

my.main.f <- function(xmat){
  return(apply(xmat, 1, my.sub.f))
}

myXmat <- myABCmat(20,50)
my.main.f(myXmat)

# tab1<-table(x[1,])
# names(tab1)[which.max(tab1)]
# names(tab1)[which(tab1==max(tab1))]
# freq_char(x)
```


```{r}
x1 <- sample(c("F","M"), 100, prob=c(0.3,0.7), replace=T)
x2 <- sample(c('A','W'), 100, prob = c(0.5,0.5), replace = T)
x1
x2
data1 <- data.frame(x1,x2)
data1
table(data1$x1,data1$x2)
```

```{r}
x<-c(5,12,123,123123)
x[x==max(x)]
x[which(x==max(x))]
x[which.max(x)]
```

# Note 4
dnorm: density function of the normal distribution
pnorm: cumulative density function of the normal distribution
qnorm: quantile function of the normal distribution
rnorm: random sampling from the normal distribution
```{r}
daily.intake <- c(5260, 5470, 5640, 6180, 6390, 6515,
    6805, 7515, 8230, 8770)
mean(daily.intake)
myOneSampT <- function(x, mu=0){
  x <- na.omit(x)
  n <- length(x)
  t0 <- sqrt(n)*(mean(x)-mu)/sd(x)
  pval <- 2*pt(abs(t0),df=n-1,lower.tail=FALSE)
  
  return(list(t0=t0,pval=pval))
}

myOneSampT(daily.intake,mu=7725)
t.test(daily.intake,mu=7725)
```
```{r}
x <- daily.intake
mu <- 7725
my.wilcox.test <- function(x,mu=0){
x <- x-mu 
n <- length(x)
xr <- rank(abs(x))
Splus <- sum(xr[x>0])

Splus0 <- 0 

for (i in 1:n){
  Splus0 <- c(Splus0, apply(combn(1:n,i),2,sum))
} # generating all possible S+ 

#length(Splus0)
#2^n
p1 <- length(which(Splus0 >= Splus))/length(Splus0) #left tail 
p2 <- length(which(Splus0 <= Splus))/length(Splus0) #right tail 
pv <- min(2*min(p1,p2),1)

return(list(Splus=Splus,pv=pv))
}
my.wilcox.test(daily.intake, mu=7725)

```

# wicoxon sum-rank test with Z approximation
```{r}
wilcox_signed_rank_z_approx <- function(x, mu=0) {
  n <- length(x)
  x_diff <- x - mu
  x_diff_abs_ranked <- rank(abs(x_diff))
  Splus <- sum(x_diff_abs_ranked[x_diff > 0])
  Sminus <- n * (n + 1) / 2 - Splus
  Z <- (Splus - n * (n + 1) / 4) / sqrt(n * (n + 1) * (2 * n + 1) / 24)
  p_value <- 2 * pnorm(abs(Z), lower.tail = FALSE)
  return(list(Splus = Splus, Z = Z, p_value = p_value))
}

wilcox_signed_rank_z_approx(daily.intake, mu=7725)
```
# wicoxon sum-rank test with Z approximation(tied rank)
```{r}
wilcox_signed_rank_z_approx_with_ties <- function(x, mu=0) {
  n <- length(x)
  x_diff <- x - mu
  x_diff_abs_ranked <- rank(abs(x_diff))
  x_diff_abs_ranked_average <- numeric(n)
  current_rank <- 1
  current_tie_sum <- 0
  current_tie_count <- 0
  for (i in 1:n) {
    current_tie_sum <- current_tie_sum + x_diff_abs_ranked[i]
    current_tie_count <- current_tie_count + 1
    if (i == n || x_diff_abs_ranked[i] != x_diff_abs_ranked[i + 1]) {
      x_diff_abs_ranked_average[(current_rank):(current_rank + current_tie_count - 1)] <- current_tie_sum / current_tie_count
      current_rank <- current_rank + current_tie_count
      current_tie_sum <- 0
      current_tie_count <- 0
    }
  }
  Splus <- sum(x_diff_abs_ranked_average[x_diff > 0])
  Z <- (Splus - n * (n + 1) / 4) / sqrt(n * (n + 1) * (2 * n + 1) / 24)
  p_value <- 2 * pnorm(abs(Z), lower.tail = FALSE)
  return(list(Splus = Splus, Z = Z, p_value = p_value))
}

```

Exercise: Write your own function to compute the Spearman rank correlation between two variables
```{r}
x <- c(rnorm(10),NA)
y <- c(NA,rnorm(10))
my.spearman <- function(x,y){
id <- which(is.na(x)==FALSE & is.na(y)==FALSE)
x <- x[id]
y <- y[id]
rx <- rank(x)
ry <- rank(y)
N <- length(x)
d<- rx - ry
rs <- 1-6*sum(d^2)/(N^3-N)
return(rs)
}
```

-------------
kruskal wallis 
```{r}
y1 <- rnorm(7)
y2 <- rnorm(6)
y3 <- rnorm(7)
y <- c(y1,y2,y3)
n <- c(7,6,7)
group <- c(rep(1,7),rep(2,6),rep(3,7))
ydata <- data.frame(y=y, group = factor(group))
ks.res <- kruskal.test(y~group, data = ydata)

yrankdata <- data.frame(y=rank(y),group = factor(group))
summary(aov(y~group, data = yrankdata))

N <- sum(n)
K <- 3 
(N-K)*ks.res$stat/((K-1)*(N-1-ks.res$stat))
```

```{r}
matSF <- matrix(c(9,4,12-9,13-4),nrow=2,byrow=TRUE)
colnames(matSF) <- c("P1","P2")
rownames(matSF) <- c("Succ","Fail")
prop.test(matSF)
fisher.test(matSF)
chisq.test(matSF)
```

```{r}
caff.marital <- matrix(c(652, 1537, 598, 242, 36, 46,
    38, 21, 218, 327, 106, 67), nrow = 3, byrow = T)
colnames(caff.marital) <- c("0", "1-150", "151-300",
    ">300")
rownames(caff.marital) <- c("Married", "Prev.married",
    "Single")

mychisq <- function(obs1){
N <- sum(obs1)
r <- dim(obs1)[1]
c <- dim(obs1)[2]
rowS <- apply(obs1, 1, sum)
colS <- apply(obs1, 2, sum)

rowS

expCt <- as.matrix(rowS,ncol=1)%*%colS/N
expCt

if(r==2&c==2){
  chisq.stat <- sum((abs(obs1-expCt)-0.5)^2 / expCt)
} else chisq.stat <- sum((obs1-expCt)^2/expCt)

pv <- pchisq(chisq.stat, df=(r-1)*(c-1), lower.tail = FALSE)
return (list(stat=chisq.stat,pvalue =pv))
}
mychisq(obs1)
```




```{r}
my.chi <- function(r,c){
  for (i in 1:r):{
    for (j in 1:c):{
      expected <- data[i,]*
    }
}
}
```

```{r}
x <- c("a","b","c")
y<-paste(x,collapse = "")
y
```

